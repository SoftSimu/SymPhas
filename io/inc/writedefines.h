
/* ***************************************************************************
 * This file is part of the SymPhas library, a framework for implementing
 * solvers for phase-field problems with compile-time symbolic algebra.
 *
 * Copyright (c) 2018-2021 by Steven A. Silber and Mikko Karttunen
 *
 * SymPhas is free software, which can be redistributed or modified under
 * the terms of the GNU Lesser General Public License (LGPL) as published
 * by the Free Software Foundation; LGPL version 3, or later versions at
 * your choice.
 *
 * SymPhas is distributed with the faith that it will be helpful and
 * practical but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
 * General Public License for more details.
 *
 * ***************************************************************************
 *
 * MODULE:  io
 * PURPOSE: Defines basic parts of the output (writing) functionality.
 * Includes definitions which are used for finding files and formatting names.
 *
 * ***************************************************************************
 */

#pragma once

#include "io.h"
#include "plottername.h"
#include "gridfunctions.h"

namespace symphas::internal
{
	template<typename T>
	struct field_array_t {};


	template<size_t D, typename T>
	struct non_parameterized_type_impl;

	template<size_t D, typename T>
	using non_parameterized_type = typename non_parameterized_type_impl<D, T>::type;
}

/* forward declaration of Model as required by the writing utility
 * in order to appropriately deal with the model information
 */
template<size_t D, typename Sp, typename... S>
struct Model;
template<size_t D, typename Sp, typename... Ts>
using ArrayModel = Model<D, Sp, symphas::internal::field_array_t<void>, Ts...>;


#define DEFAULT_FIELD_NAME "field"


/* the generic format of an output file that is written by the program
 * if there are individual files for every index, then the index is prepended
 * 
 * in general, the first string format indicates the type of data contained by the
 * data file, and the second string format is the subdata of that category, most
 * commonly the system id
 */
#define OUTPUT_DATA_FILE_FMT "%s_%s." OUTPUT_DATA_EXTENSION
#define OUTPUT_DATA_FILE_INDEX_FMT "%s_%s_%0" OUTPUT_INDEX_WIDTH_STR "d." OUTPUT_DATA_EXTENSION
#define OUTPUT_DATA_FILE_LATEX_FMT "%s_" OUTPUT_DATA_FILE_FMT
#define OUTPUT_DATA_FILE_LATEX_INDEX_FMT "%s_" OUTPUT_DATA_FILE_INDEX_FMT



/* the name of the plot file
 * when generated for the case of latex output, instead of the simple dataname, additional
 * information is provided in the title including the title of the simulation and the id of
 * the system which is being plotted
 * moreover, the case of latex output changes the output of
 */
#define PHASEFIELD_PLOT_LOC_FMT "%s/" PLOT_DIR "/%s." OUTPUT_PLOT_EXTENSION
#define POSTPROC_PLOT_LOC_FMT "%s/" PLOT_DIR "/%s%zd." OUTPUT_PLOT_EXTENSION


/* the full file name including directory for the data files generated by the solution
 * in the case of latex output, the title of the simulation preceeds the file name format
 */

#define OUTPUT_LOC_FMT OUTPUT_DATA_DIR "/" OUTPUT_DATA_FILE_FMT
#define OUTPUT_LOC_INDEX_FMT OUTPUT_DATA_DIR "/" OUTPUT_DATA_FILE_INDEX_FMT
#define OUTPUT_LOC_LATEX_FMT OUTPUT_DATA_DIR "/" OUTPUT_DATA_FILE_LATEX_FMT
#define OUTPUT_LOC_LATEX_INDEX_FMT OUTPUT_DATA_DIR "/" OUTPUT_DATA_FILE_LATEX_INDEX_FMT


 /* the name of the latex file that will be generated by gnuplot when the plotfile is executed
  */
#define OUTPUT_LATEX_FILE_FMT "%s_%s" POSTFIX_ID_FMT "_%d.tex"

//! \cond
#define DECLARE_SAVE_GRID_FUNCTIONS \
	void save_grid(const scalar_t* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);							 \
	void save_grid(const complex_t* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);							 \
	void save_grid(const double_arr2* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);						 \
	void save_grid(const vector_t<3>* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);						 \
	void save_grid(const vector_t<2>* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);						 \
	void save_grid(const vector_t<1>* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);						 \
	void save_grid(const scalar_ptr_t(&grid)[3], symphas::io::write_info winfo, symphas::grid_info ginfo);					 \
	void save_grid(const scalar_ptr_t(&grid)[2], symphas::io::write_info winfo, symphas::grid_info ginfo);					 \
	void save_grid(const scalar_ptr_t(&grid)[1], symphas::io::write_info winfo, symphas::grid_info ginfo);

#define DECLARE_SAVE_GRID_PLOTTING_FUNCTIONS \
	void save_grid_plotting(const scalar_t* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);					 \
	void save_grid_plotting(const complex_t* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);				 \
	void save_grid_plotting(const double_arr2* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);				 \
	void save_grid_plotting(const vector_t<3>* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);				 \
	void save_grid_plotting(const vector_t<2>* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);				 \
	void save_grid_plotting(const vector_t<1>* grid, symphas::io::write_info winfo, symphas::grid_info ginfo);				 \
	void save_grid_plotting(const scalar_ptr_t(&grid)[3], symphas::io::write_info winfo, symphas::grid_info ginfo);			 \
	void save_grid_plotting(const scalar_ptr_t(&grid)[2], symphas::io::write_info winfo, symphas::grid_info ginfo);			 \
	void save_grid_plotting(const scalar_ptr_t(&grid)[1], symphas::io::write_info winfo, symphas::grid_info ginfo);			 \

#define DECLARE_SAVE_GRID_ALL_FUNCTIONS DECLARE_SAVE_GRID_FUNCTIONS DECLARE_SAVE_GRID_PLOTTING_FUNCTIONS

//! \endcond


namespace symphas::io
{
	void write_data_entry(FILE* out, int data);
	void write_data_entry(FILE* out, scalar_t data);
	void write_data_entry(FILE* out, complex_t data);
	template<typename T, size_t N>
	void write_data_entry(FILE* out, T(&data)[N]);
	void write_data_entry(FILE* out, axis_2d_type data);
	void write_data_entry(FILE* out, axis_3d_type data);

	template<typename... Ts, size_t... Is>
	void write_data_entry(FILE* out, std::tuple<Ts...> const& data, std::index_sequence<Is...>);
	template<typename... Ts>
	void write_data_entry(FILE* out, std::tuple<Ts...> const& data);

	//! Information about the data file to be written.
	/*!
	 * Contains information about the data file that is written to disk,
	 * specifically about the type of data. A file name is chosen based on
	 * this information, such as the data solution index and ID.
	 */
	struct write_info
	{
		write_info(const char* dir_str_ptr, iter_type index, size_t id, DataFileType type) : 
			dir_str_ptr{ dir_str_ptr }, index{ index }, id{ id }, type{ type }, intervals{} {}
		write_info(const char* dir_str_ptr, iter_type index, size_t id) : 
			write_info{ dir_str_ptr, index, id, DataFileType::GENERIC_DATA } {}

		write_info(iter_type index, size_t id) : write_info{ ".", index, id, DataFileType::GENERIC_DATA } {}
		write_info(size_t id) : write_info{ ".", 0, id, DataFileType::GENERIC_DATA } {}
		write_info() : write_info{ ".", 0, 0, DataFileType::GENERIC_DATA } {}

		using interval_t = std::map<Axis, double[2]>;

		auto domain_left(Axis ax) const
		{
			return intervals.at(ax)[0];
		}

		auto domain_right(Axis ax) const
		{
			return intervals.at(ax)[1];
		}

		const char* dir_str_ptr;	//!< Pointer (unowned) to the string specifying directory name.
		iter_type index;			//!< The solution index at which the data is saved.
		size_t id;					//!< The ID of the grid being written.
		DataFileType type;			//!< The type of data that is written, typically this should be phase field data.
		interval_t intervals;		//!< Extent of the global domain in the spatial axes.
	};


	//! Produces a file name for data to be written to.
	/*! 
	 * Given the directory, data name type, as well as the index/id 
	 * information, the type is used in order to build a name and print it to 
	 * the given output parameter.
	 * 
	 * \param dir The directory location relative to the current executing
	 * directory.
	 * \param data_name The name of the data which is used in building the
	 * name of the file.
	 * \param index The index of the data that will be written into the file,
	 * used when the params::single_output_file is true.
	 * \param id The index number associated with the data itself, as opposed
	 * to the current snapshot of the data. Typically corresponds to the
	 * phase field index.
	 * \param type The type of the data that will be written to the file.
	 * \param[out] out The location into which the final name of the datafile 
	 * is written.
	 */
	void copy_data_file_name(const char* dir, const char* data_name, int index, size_t id, DataFileType type, char* out);

	//! Specialization based on an empty (unspecified) data name.
	void copy_data_file_name(const char* dir, int index, size_t id, DataFileType type, char* out);

	//! Opens a datafile.
    /*
     * Returns the opened file pointer (if it is successful) for the data file, 
	 * standardized for any data saving methods based on the enum DataFileType.
	 * If the single_output_file parameter is true, then prepend to the 
	 * previous datafile with the given name, with no index in the name.
	 * 
	 * \param dir The directory location relative to the current executing
	 * directory.
	 * \param data_name the name of the data which is used in building the name
	 * of the file.
	 * \param index The index of the data that will be written into the file,
	 * used when the params::single_output_file is true.
	 * \param id The index number associated with the data itself, as opposed
	 * to the current snapshot of the data. Typically corresponds to the
	 * phase field index.
	 * \param type The type of the data that will be written to the file.
     */
	FILE* open_data_file(const char* dir, const char* data_name, int index, size_t id, DataFileType type);

	//! Specialization based on an empty (unspecified) data name.
	FILE* open_data_file(const char* dir, int index, size_t id, DataFileType type);
	

	//! Open the plotting configuration file of post-processing data
	/*!
	 * Open the file into which the plotting configuration of the 
	 * post-processing data is saved.
	 */
	FILE* open_postproc_plot_file(const char* dir, const char* name, size_t id, const char* mode);


	/*!
	 * Used for generalized writing of plot configuration files, typically for
	 * post-processing utilities.
	 *
	 * The function expects an array of strings, which will be printed to the 
	 * file, the only rule is that the last string must be
	 * the one with the file name and data index as format argument. The 
	 * data file name will be automatically written based on the standardized
	 * methods.
	 *
	 * \param sets The strings that are used to write the configuration.
	 * \param n The length of the string array.
	 * \param dir The directory location relative to the current executing
	 * directory.
	 * \param name The name of the data that is written. Simply a unique 
	 * identifier.
	 * \param index The index of the data that will be written into the file,
	 * used when the params::single_output_file is true.
	 * \param id The index number associated with the data itself, as opposed
	 * to the current snapshot of the data. Typically corresponds to the
	 * phase field index.
	 * \param prepend An additional string which is printed to the plot file
	 * before the final specification string.
	 */
	void write_postproc_plot_file(const char* (*sets), len_type n, const char* dir, const char* name, int index, size_t id, const char* prepend = "");

	//! Based on write_postproc_plot_file(), used to create a new plot file.
	void overwrite_postproc_plot_file(const char* (*sets), len_type n, const char* dir, const char* name, int index, size_t id, int entry_index, const char* prepend = "");
	
	//! Based on write_postproc_plot_file(), used to add to an existing file.
	void append_postproc_plot_file(const char* set, const char* dir, const char* name, int index, size_t id, int entry_index, const char* prepend = "");


	//! Write data of the grid to a file to be used in plotting.
	/*!
	 * Values from the given array are written to a file in a form which
	 * is suitable to be ingested by the plotting program. Typically,
	 * the \p ginfo parameter should be given in a way such that the correct
	 * data from the array is written.
	 *
	 * \param values The array that is written to file.
	 * \param winfo Information about the file to write.
	 * \param ginfo Information about the grid that is saved.
	 */
	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value, int>>
	void save_grid_plotting(const T* values, symphas::io::write_info winfo, symphas::grid_info ginfo);


	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid_plotting(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid_plotting(const T(*values)[N], symphas::io::write_info winfo, symphas::grid_info ginfo);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid_plotting(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid_plotting(T* const(&values)[N], symphas::io::write_info winfo, symphas::grid_info ginfo);


	//! Write all grid data to a file, typically used for backups.
	/*!
	 * All the values from the given array are written to a file, including
	 * information about the data grid that the array refers to. This format
	 * is typically condensed, as this the raw output and not meant for
	 * ingestion by plotting programs.
	 *
	 * \param values The array that is written to file.
	 * \param winfo Information about the file to write.
	 * \param ginfo Information about the grid that is saved.
	 */
	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value, int>>
	void save_grid(const T* values, symphas::io::write_info winfo, symphas::grid_info ginfo);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(const T(*values)[N], symphas::io::write_info winfo, symphas::grid_info ginfo);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(T* const(&values)[N], symphas::io::write_info winfo, symphas::grid_info ginfo);


	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value, int>>
	void save_grid(const T* values, symphas::grid_info ginfo);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(const T(*values)[N], symphas::grid_info ginfo);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(T* const(&values)[N], symphas::grid_info ginfo);


	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value, int>>
	void save_grid(const T* values, symphas::io::write_info winfo, const len_type* dims, size_t dimension);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(const T(*values)[N], symphas::io::write_info winfo, const len_type* dims, size_t dimension);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(T* const(&values)[N], symphas::io::write_info winfo, const len_type* dims, size_t dimension);


	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value, int>>
	void save_grid(const T* values, const len_type* dims, size_t dimension);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(const T(*values)[N], const len_type* dims, size_t dimension);

	//! Write all grid data to a file, typically used for backups.
	/*!
	 * See save_grid(T*, symphas::io::write_info, symphas::grid_info).
	 */
	template<typename T, size_t N>
	void save_grid(T* const(&values)[N], const len_type* dims, size_t dimension);





	//! Writes a plotting configuration file for the given model.
	/*!
	 * Given a model, a plotting configuration file corresponding to the 
	 * selected output method is written. The label names of each of the phase
	 * field systems constituting the model. The output is written to the 
	 * provided directory under a specific name format, refer to definitions
	 * #PHASEFIELD_PLOT_LOC_FMT and #PHASEFIELD_DATA_NAME.
	 *
	 * The configuration written is determined by the io writer.
	 * See params::writer.
	 *
	 * The parameters of the simulation are used to programmatically
	 * write an appropriate configuration for the writer.
	 * Each writer has only one plotting configuration.
	 *
	 * \param model The model for which to write the plotting configuration.
	 * \param names List of labels given to each of the phase fields that are plotted. This
	 * list must have at least as many elements as there are systems, otherwise if there are
	 * too few names, the function will access invalid memory.
	 * \param directory Parent directory containing the plotting configuration file and its
	 * enclosing folder.
	 * \param save A save object which determines at which indices in the simulation the model
	 * system data will be persisted so that the chosen plotting method will include it in the
	 * generated plot. This information is used in the configuration to refer to the data at
	 * each of the saved indices.
	 */
	template<typename M>
	void write_plot_config(M const& model, const char* directory, const char* const* names, SaveParams const& save);

	//! Writes a plotting configuration file for the given model.
	/*!
	 * Writes a configuration using default field names. @see 
	 * symphas::io::write_plot_config().
	 */
	//template<typename M>
	//void write_plot_config(M const& model, const char* directory, SaveParams const& save);




	template<typename T, size_t D>
	void print_grid(FILE* out, Grid<T, D> const& grid);
	template<typename T, size_t D>
	void print_grid(Grid<T, D> const& grid);
	template<typename T, size_t D>
	void print_grid(FILE* out, RegionalGrid<T, D> const& grid);
	template<typename T, size_t D>
	void print_grid(RegionalGrid<T, D> const& grid);
	template<typename T, size_t D>
	void print_region(FILE* out, RegionalGrid<T, D> const& grid);
	template<typename T, size_t D>
	void print_region(RegionalGrid<T, D> const& grid);

	template<size_t D>
	void print_region(FILE* out, grid::region_interval<D> const& region, char inside = 'X', char outside = '.');
	template<size_t D>
	void print_region(FILE* out, grid::region_interval_multiple<D> const& region, char inside = 'X', char outside = '.');
	template<size_t D>
	void print_region(grid::region_interval<D> const& region, char inside = 'X', char outside = '.');
	template<size_t D>
	void print_region(grid::region_interval_multiple<D> const& region, char inside = 'X', char outside = '.');


}




